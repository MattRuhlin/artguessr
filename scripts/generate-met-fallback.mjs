#!/usr/bin/env node

// Generate a large hard-coded fallback list of GameObject-like entries
// from the Met Collection API and write them to src/data/met-fallback.ts

const fs = await import('fs');
const path = await import('path');

const MET_API_BASE = 'https://collectionapi.metmuseum.org/public/collection/v1';

// Simple rate limiter: cap at 50 req/s to be safe
const RATE_LIMIT_RPS = 50;
let availableTokens = RATE_LIMIT_RPS;
const pendingQueue = [];

function drainQueue() {
  while (availableTokens > 0 && pendingQueue.length > 0) {
    const run = pendingQueue.shift();
    availableTokens--;
    run();
  }
}

setInterval(() => {
  availableTokens = RATE_LIMIT_RPS;
  drainQueue();
}, 1000);

function schedule(task) {
  return new Promise((resolve, reject) => {
    const run = () => {
      Promise.resolve()
        .then(task)
        .then(resolve)
        .catch(reject);
    };
    if (availableTokens > 0) {
      availableTokens--;
      run();
    } else {
      pendingQueue.push(run);
    }
  });
}

async function fetchWithRetry(url, maxRetries = 3) {
  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), 15000);
      const doFetch = () => fetch(url, { signal: controller.signal, headers: { 'Accept': 'application/json' } });
      const response = await schedule(() => doFetch());
      clearTimeout(timeoutId);
      if (response.status >= 500 && attempt < maxRetries) {
        const delay = Math.pow(2, attempt) * 1000;
        await new Promise(r => setTimeout(r, delay));
        continue;
      }
      return response;
    } catch (err) {
      if (attempt === maxRetries) throw err;
      const delay = Math.pow(2, attempt) * 1000;
      await new Promise(r => setTimeout(r, delay));
    }
  }
  throw new Error('Max retries exceeded');
}

function escapeString(str) {
  return (str || '')
    .replace(/\\/g, '\\\\')
    .replace(/'/g, "\\'")
    .replace(/`/g, '\\`')
    .replace(/\r?\n/g, ' ')
    .replace(/[\u0000-\u001F\u007F]/g, '');
}

async function main() {
  const outputPath = path.resolve(process.cwd(), 'src/data/met-fallback.ts');
  const queries = ['the','of','and','a','e','i','o','u','art','painting','sculpture','ceramic','textile','print','metal','wood','glass','bronze'];
  const desiredCount = 500; // target size
  const maxIdsPerQuery = 5000;

  const idSet = new Set();

  for (const q of queries) {
    try {
      const resp = await fetchWithRetry(`${MET_API_BASE}/search?hasImages=true&q=${encodeURIComponent(q)}`);
      if (!resp.ok) continue;
      const data = await resp.json();
      const ids = data.objectIDs || [];
      for (const id of ids) {
        idSet.add(id);
        if (idSet.size >= desiredCount * 10) break;
      }
      if (idSet.size >= desiredCount * 10) break;
    } catch {}
  }

  const allIds = Array.from(idSet);
  for (let i = allIds.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [allIds[i], allIds[j]] = [allIds[j], allIds[i]];
  }

  const centroidJsonPath = path.resolve(process.cwd(), 'src/data/country-centroids.json');
  const centroidJson = JSON.parse(await fs.promises.readFile(centroidJsonPath, 'utf8'));
  const validCountries = new Set(Object.keys(centroidJson));

  const results = [];

  for (const id of allIds) {
    if (results.length >= desiredCount) break;
    try {
      const resp = await fetchWithRetry(`${MET_API_BASE}/objects/${id}`);
      if (!resp.ok) continue;
      const obj = await resp.json();
      if (!obj || !obj.isPublicDomain) continue;
      const imageUrl = obj.primaryImageSmall || obj.primaryImage;
      if (!imageUrl) continue;
      const country = (obj.country || '').trim();
      if (!country) continue;
      if (!validCountries.has(country)) continue;

      // Keep record
      results.push({
        objectId: obj.objectID,
        imageUrl: imageUrl,
        title: obj.title || 'Untitled',
        artist: obj.artistDisplayName || 'Unknown Artist',
        year: obj.objectDate || 'Unknown Date',
        country,
        locationDescription: country,
        medium: (obj.medium || '').trim() || undefined
      });
    } catch {}
  }

  // Build file content
  const header = `import { getCountryCentroid } from '@/lib/location';\nimport type { GameObject } from '@/lib/met';\n\n// Auto-generated by scripts/generate-met-fallback.mjs\nexport const MET_FALLBACK_GAME_OBJECTS: GameObject[] = [\n`;

  const lines = results.map(item => {
    const title = escapeString(item.title);
    const artist = escapeString(item.artist);
    const year = escapeString(item.year);
    const country = escapeString(item.country);
    const imageUrl = escapeString(item.imageUrl);
    const medium = item.medium ? `,\n  medium: '${escapeString(item.medium)}'` : '';
    return `  {\n    objectId: ${item.objectId},\n    imageUrl: '${imageUrl}',\n    title: '${title}',\n    artist: '${artist}',\n    year: '${year}',\n    country: '${country}',\n    locationDescription: '${country}',\n    target: getCountryCentroid('${country}')!${medium}\n  }`;
  });

  const footer = `\n];\n`;

  const content = header + lines.join(',\n') + footer;
  await fs.promises.mkdir(path.dirname(outputPath), { recursive: true });
  await fs.promises.writeFile(outputPath, content, 'utf8');
  console.log(`Wrote ${results.length} fallback items to ${outputPath}`);
}

main().catch(err => {
  console.error(err);
  process.exit(1);
});

